Here are some informative notes about this project.

1. How to use 'jlc'
A more detailed description can be obtained by 'jlc --help'.

2. The output of 'jlc'
If parsing and type checking success, it outputs a "OK" in the fist line, followed by the
tokens parsed from the program and a full display of the program.
If parsing fails, it shows the tokens so far parsed and give out the information about the
specific syntax error.
If type checking fails, it shows the reason of the error and the statement where the error
stems from and the function name which contains the statement.

3. Shift/Reduce conflicts
(A more detailed information about 'shift/reduce' conflicts can be found in the file 'ParJavalette.info', which is generated by the 'bnfc' tool)
  1) State 26
	Stmt -> Ident . '=' Expr ';'                        (rule 19)
	Stmt -> Ident . '++' ';'                            (rule 21)
	Stmt -> Ident . '--' ';'                            (rule 22)
	Expr7 -> Ident .                                    (rule 42)
	Expr7 -> Ident . '(' ListExpr ')'                   (rule 48)

    ......

    '='            shift, and enter state 95
            (reduce using rule 42)

    This conflict arises because we have both grammars:
        Evar. Expr7 ::= Ident ;
        Ass. Stmt ::= Ident "=" Expr ";" ;

    This conflict doesn't matter since the default behaviour, which treats the 'Ident' as 'Ident' part of a statement, is our desired effect

  2) State 63
    Object -> Array .                                   (rule 70)
	Array -> Array . '[' Expr ']'                       (rule 72)

    ......

    '['            shift, and enter state 115
			(reduce using rule 70)

    This conflict arises because we have grammars:
        ENew. Expr7 ::= "new" Object;
        EIndex. Expr6 ::= Expr6 "[" Expr "]";
        ArrayObj. Object ::= Array;
        MArray. Array ::= Array "[" Expr "]";
        
    This conflict doesn't matter since the default behaviour, which treats 'Array' as a component of a 'MArray', is our desired effect

  3) State 133
    Stmt -> 'if' '(' Expr ')' Stmt .                    (rule 25)
	Stmt -> 'if' '(' Expr ')' Stmt . 'else' Stmt        (rule 26)

    ......

    'else'         shift, and enter state 137
			(reduce using rule 25)

    This conflict arises because we have grammars:
        Cond. Stmt ::= "if" "(" Expr ")" Stmt;
        CondElse. Stmt ::= "if" "(" Expr ")" Stmt "else" Stmt;
        
    This conflict doesn't matter since the default behaviour, which prefers a 'if else' statement first, is our desired effect


4. Extensions
  1) arrays1
  2) arrays2